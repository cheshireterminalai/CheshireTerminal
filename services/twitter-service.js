import { TwitterApi } from 'twitter-api-v2';
import { logger } from '../utils/logger.js';
import dotenv from 'dotenv';

dotenv.config();

class TwitterService {
    constructor() {
        this.client = new TwitterApi({
            appKey: process.env.TWITTER_API_KEY,
            appSecret: process.env.TWITTER_API_KEY_SECRET,
            accessToken: process.env.TWITTER_ACCESS_TOKEN,
            accessSecret: process.env.TWITTER_ACCESS_TOKEN_SECRET,
        });

        this.rwClient = this.client.readWrite;
        logger.info('Twitter service initialized');
    }

    async tweetNFTMint(nft, mintAddress) {
        try {
            const tweetText = this.generateTweetText(nft, mintAddress);
            
            // If there's an image, upload it first
            let mediaId = null;
            if (nft.image) {
                const imageBuffer = await fetch(nft.image).then(res => res.buffer());
                mediaId = await this.rwClient.v1.uploadMedia(imageBuffer, { type: 'png' });
            }

            // Send tweet
            const tweet = await this.rwClient.v2.tweet({
                text: tweetText,
                ...(mediaId && { media: { media_ids: [mediaId] } })
            });

            logger.info('Tweet sent successfully', { tweetId: tweet.data.id });
            return tweet;
        } catch (error) {
            logger.error('Failed to send tweet', error);
            throw error;
        }
    }

    generateTweetText(nft, mintAddress) {
        // Get rarity traits
        const rarityTraits = nft.attributes
            .filter(attr => attr.trait_type === 'rarity' || attr.trait_type === 'viralFactor')
            .map(attr => attr.value)
            .join(' ');

        // Format mint address for display
        const shortAddress = `${mintAddress.slice(0, 4)}...${mintAddress.slice(-4)}`;

        // Generate tweet text
        return `ðŸŽ¨ Just minted: ${nft.name}!\n\n` +
               `${rarityTraits ? `âœ¨ ${rarityTraits}\n` : ''}` +
               `ðŸŒŸ ${nft.attributes.map(attr => 
                    attr.trait_type !== 'rarity' && attr.trait_type !== 'viralFactor' ? 
                    `${attr.value}` : '').filter(Boolean).join(' | ')}\n\n` +
               `ðŸ”— View on Solana Explorer:\n` +
               `https://explorer.solana.com/address/${mintAddress}\n\n` +
               `#NFT #Solana #AIArt ${nft.attributes.map(attr => 
                    `#${attr.value.replace(/\s+/g, '')}`).join(' ')}`;
    }

    async tweetCollectionStart() {
        try {
            const tweet = await this.rwClient.v2.tweet({
                text: `ðŸš€ Starting to mint a new collection of 69 AI-generated NFTs on Solana!\n\n` +
                      `ðŸŽ¨ Each piece is unique and generated by our autonomous AI agent.\n\n` +
                      `Follow this thread for live updates as each NFT is minted! ðŸ§µ\n\n` +
                      `#NFT #Solana #AIArt #NFTCollection`
            });

            logger.info('Collection start tweet sent', { tweetId: tweet.data.id });
            return tweet;
        } catch (error) {
            logger.error('Failed to send collection start tweet', error);
            throw error;
        }
    }

    async tweetCollectionComplete(collectionSize) {
        try {
            const tweet = await this.rwClient.v2.tweet({
                text: `âœ¨ Collection minting complete! âœ¨\n\n` +
                      `Successfully minted ${collectionSize} unique AI-generated NFTs on Solana.\n\n` +
                      `Each piece is a unique blend of meme culture and AI creativity.\n\n` +
                      `Thanks for following along! ðŸŽ‰\n\n` +
                      `#NFT #Solana #AIArt #NFTCollection`
            });

            logger.info('Collection complete tweet sent', { tweetId: tweet.data.id });
            return tweet;
        } catch (error) {
            logger.error('Failed to send collection complete tweet', error);
            throw error;
        }
    }
}

export const twitterService = new TwitterService();
